import NIOCore

extension MySQLProtocol {
    /// `Protocol::HandshakeResponse`
    ///
    /// Depending on the servers support for the `CLIENT_PROTOCOL_41` capability and the clients
    /// understanding of that flag the client has to send either a `Protocol::HandshakeResponse41`
    /// or `Protocol::HandshakeResponse320`.
    ///
    /// Handshake Response Packet sent by 4.1+ clients supporting `CLIENT_PROTOCOL_41` capability,
    /// if the server announced it in its Initial Handshake Packet. Otherwise (talking to an old server)
    /// the `Protocol::HandshakeResponse320` packet must be used.
    ///
    /// - Note: This implementation does not support the `HandshakeResponse320` packet.
    ///
    /// - Note: All string fields must be representable in the character set specified in the packet. The current
    ///   implementation theoretically allows using character sets other than `utf8mb4`, but doing so is **not**
    ///   recommended.
    ///
    /// https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse
    /// https://mariadb.com/kb/en/connection/
    struct HandshakeResponse41: MySQLPacketCodable {
        /// `capability_flags` (4)
        /// capability flags of the client as defined in `Protocol::CapabilityFlags`
        var capabilities: MySQLProtocol.CapabilityFlags
        
        /// `max_packet_size` (4)
        /// max size of a command packet that the client wants to send to the server
        var maxPacketSize: UInt32
        
        /// `character_set` (1)
        /// connection's default character set as defined in `Protocol::CharacterSet`.
        var characterSet: MySQLProtocol.CharacterSet
        
        /// username (`string.fix_len`)
        /// name of the SQL account which client wants to log in this string should be interpreted using the character set indicated by character set field.
        var username: String
        
        /// auth-response (`string.NUL`)
        /// opaque authentication response data generated by Authentication Method indicated by the plugin name field.
        var authResponse: ByteBuffer
        
        /// database (`string.NUL`)
        /// initial database for the connection -- this string should be interpreted using the character set indicated by character set field.
        var database: String
        
        /// auth plugin name (`string.NUL`)
        /// the Authentication Method used by the client to generate auth-response value in this packet. This is an UTF-8 string.
        var authPluginName: String
        
        /// connection attributes (pairs of `string.len_enc`)
        /// per-connection attributes sent by the client when `CLIENT_CONNECT_ATTRS` is available.
        ///
        /// - Note: Some attributes are set automatically by the default initializer when the capability flags indicate appropriate support. See
        ///   ``init(capabilities:maxPacketSize:characterSet:username:authResponse:database:authPluginName:connectionAttributes:)`` for more details.
        var connectionAttributes: [ConnectionAttributeName: String]
        
        /// Creates a new `MySQLHandshakeResponse41`
        ///
        /// - Note: The provided connection attributes are ignored if the capabilities flags do not specify `CLIENT_CONNECT_ATTRS`. Otherwise, the
        ///   provided attributes replace any attributes which would otherwise be added by default. Specifying `nil` (the default) results in sending
        ///   the default attribute set; specifying an empty dictionary results in sending no attributes whatsoever. To include some or all of the
        ///   default attributes alongside others, and/or with custom values,  use ``ConnectionAttributeName.defaultAttributeValues()`` to retrieve
        ///   the initial set of default values.
        init(
            capabilities: MySQLProtocol.CapabilityFlags,
            maxPacketSize: UInt32,
            characterSet: MySQLProtocol.CharacterSet,
            username: String,
            authResponse: ByteBuffer,
            database: String,
            authPluginName: String,
            connectionAttributes: [ConnectionAttributeName: String]? = nil
        ) {
            self.capabilities = capabilities
            self.maxPacketSize = maxPacketSize
            self.characterSet = characterSet
            self.username = username
            self.authResponse = authResponse
            self.database = database
            self.authPluginName = authPluginName
            self.connectionAttributes = connectionAttributes ?? ConnectionAttributeName.defaultAttributeValues()
        }
        
        /// `MySQLPacketEncodable` conformance.
        func encode(to packet: inout MySQLPacket, capabilities: MySQLProtocol.CapabilityFlags) throws {
            // Calculate the set of capability flags both reported by the server _and_ selected for this response.
            let sharedCapabilities = self.capabilities.intersection(capabilities)
            assert(sharedCapabilities.contains(.CLIENT_SECURE_CONNECTION), "pre-4.1 auth not supported")

            // Check auth response data isn't oversized, if needed. We don't support the case where `CLIENT_SECURE_CONNECTION`
            // isn't set, but that check is handled elsewhere so there's need to add additional logic for it here.
            guard sharedCapabilities.contains(.CLIENT_CONNECT_WITH_DB) || self.database.isEmpty else { throw Error.settingDatabaseEarlyUnsupported }
            guard sharedCapabilities.contains(.CLIENT_PLUGIN_AUTH) || self.authPluginName.isEmpty else { throw Error.authPluginsUnsupported }
            
            // N.B.: Send all specified capability flags; some are client-only and will be missing from the shared set.
            packet.payload.writeInteger(self.capabilities.general, endianness: .little)
            packet.payload.writeInteger(self.maxPacketSize, endianness: .little)
            packet.payload.writeInteger(self.characterSet.rawValue, endianness: .little)
            packet.payload.writeRepeatingByte(0, count: 19)
            packet.payload.writeInteger(sharedCapabilities.contains(.CLIENT_MYSQL) ? self.capabilities.mariaDBSpecific : 0, endianness: .little, as: UInt32.self)
            packet.payload.writeNullTerminatedString(self.username)
            if sharedCapabilities.contains(.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) {
                packet.payload.writeImmutableLengthEncodedSlice(self.authResponse)
            } else {
                try packet.payload.writeLengthPrefixed(as: UInt8.self, writeMessage: { $0.writeImmutableBuffer(self.authResponse) })
            }
            if sharedCapabilities.contains(.CLIENT_CONNECT_WITH_DB) {
                packet.payload.writeNullTerminatedString(self.database)
            }
            if sharedCapabilities.contains(.CLIENT_PLUGIN_AUTH) {
                packet.payload.writeNullTerminatedString(self.authPluginName)
            }
            if sharedCapabilities.contains(.CLIENT_CONNECT_ATTRS) {
                let subdata = self.connectionAttributes.reduce(into: ByteBuffer()) {
                    $0.writeLengthEncodedString($1.key.rawValue)
                    $0.writeLengthEncodedString($1.value)
                }
                guard subdata.writerIndex < UInt16.max else { throw Error.connectionAtrributesTooLarge }
                packet.payload.writeImmutableLengthEncodedSlice(subdata)
            }
        }

        /// `MySQLPacketDecodable` conformance.
        static func decode(from packet: inout MySQLPacket, capabilities: MySQLProtocol.CapabilityFlags) throws -> HandshakeResponse41 {
            let clientCapabilities = try packet.readInteger(endianness: .little, as: UInt32.self)
            let maxPacketSize = try packet.readInteger(endianness: .little, as: UInt32.self)
            let characterSet = try CharacterSet(rawValue: packet.readInteger(endianness: .little, as: UInt8.self))
            try packet.readReservedBytes(length: 19)
            let effectiveCapabilities = try CapabilityFlags(checking: capabilities, general: clientCapabilities, extended: packet.readInteger(endianness: .little, as: UInt32.self))
            let username = try packet.readNullTerminatedString()
            let authResponse = try effectiveCapabilities.contains(.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) ? packet.readLengthEncodedSlice() : packet.readLengthPrefixedSlice(as: UInt8.self)
            let database = try effectiveCapabilities.contains(.CLIENT_CONNECT_WITH_DB) ? packet.readNullTerminatedString() : ""
            let plugin = try effectiveCapabilities.contains(.CLIENT_PLUGIN_AUTH) ? packet.readNullTerminatedString() : ""
            var attrs: [ConnectionAttributeName: String] = [:]
            if effectiveCapabilities.contains(.CLIENT_CONNECT_ATTRS) {
                var attrData = try packet.readLengthEncodedSlice()
                while attrData.readableBytes > 0 {
                    guard let name = attrData.readLengthEncodedString(), let value = attrData.readLengthEncodedString() else { throw Error.invalidHandshakeResponse }
                    attrs[.init(name: name)] = value
                }
            }
            
            return .init(
                capabilities: effectiveCapabilities,
                maxPacketSize: maxPacketSize,
                characterSet: characterSet,
                username: username,
                authResponse: authResponse,
                database: database,
                authPluginName: plugin,
                connectionAttributes: attrs
            )
        }

        enum Error: Swift.Error {
            case invalidHandshakeResponse
            
            case authResponseDataTooLong // CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA not available and auth data longer than 255 bytes
            case settingDatabaseEarlyUnsupported // CLIENT_CONNECT_WITH_DB not available and a database name was specified for the connection
            case authPluginsUnsupported // CLIENT_PLUGIN_AUTH not available but an auth plugin was explicitly specified
            case connectionAtrributesTooLarge // CLIENT_CONNECT_ATTRS was specified and provided attributes exceed 64KiB of data
        }
    }
}

extension MySQLProtocol.CapabilityFlags {
    /// Create a `CapabilityFlags` from an existing set of flags, and the lower and upper 32-bit halves of
    /// a potentially extended flags value. The semantics are as follows:
    ///
    /// - If either the existing capability flags value _or_ the lower 32-bit raw value specify the
    ///   `CLIENT_LONG_PASSWORD` capability (also referred to as `CLIENT_MYSQL`), the upper ("extended")
    ///   raw value _must_ be zero. If it is not, an error is thrown.
    /// - If `CLIENT_LONG_PASSWORD` is not specified by either general input value, the upper raw value
    ///   is treated as extended MariaDB flags.
    ///
    /// The final `CapabilityFlags` set represents the _intersection_ of the existing capability flags value
    /// with the value resulting from the handling of the raw inputs specified above.
    ///
    /// This initializer is used by the handshake response packet decoder to gracefully handle the possible
    /// presence of MariaDB extensions and calculate the set of _effective_ capabilities in force (i.e. only
    /// those specified by both server and client).
    internal init(checking initial: Self, general: UInt32, extended: UInt32) throws {
        guard extended == 0 || (initial.general | general) & Self.CLIENT_MYSQL.general == 0 else {
            throw MySQLProtocol.HandshakeResponse41.Error.invalidHandshakeResponse
        }
        self.init(general: general, extended: extended)
        self.formIntersection(initial)
    }
}
