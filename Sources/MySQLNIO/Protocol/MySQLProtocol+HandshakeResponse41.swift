import NIOCore

extension MySQLProtocol {
    /// `Protocol::HandshakeResponse`
    ///
    /// Depending on the servers support for the `CLIENT_PROTOCOL_41` capability and the clients
    /// understanding of that flag the client has to send either a `Protocol::HandshakeResponse41`
    /// or `Protocol::HandshakeResponse320`.
    ///
    /// Handshake Response Packet sent by 4.1+ clients supporting `CLIENT_PROTOCOL_41` capability,
    /// if the server announced it in its Initial Handshake Packet. Otherwise (talking to an old server)
    /// the `Protocol::HandshakeResponse320` packet must be used.
    ///
    /// - Note: This implementation does not support the `HandshakeResponse320` packet.
    ///
    /// - Note: All string fields must be representable in the character set specified in the packet. The current
    ///   implementation theoretically allows using character sets other than `utf8mb4`, but doing so is **not**
    ///   recommended.
    ///
    /// https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse
    /// https://mariadb.com/kb/en/connection/
    struct HandshakeResponse41: MySQLPacketCodable {
        /// `capability_flags` (4)
        /// capability flags of the client as defined in `Protocol::CapabilityFlags`
        var capabilities: MySQLProtocol.CapabilityFlags
        
        /// `max_packet_size` (4)
        /// max size of a command packet that the client wants to send to the server
        var maxPacketSize: UInt32
        
        /// `character_set` (1)
        /// connection's default character set as defined in `Protocol::CharacterSet`.
        var characterSet: MySQLProtocol.CharacterSet
        
        /// username (`string.fix_len`)
        /// name of the SQL account which client wants to log in this string should be interpreted using the character set indicated by character set field.
        var username: String
        
        /// auth-response (`string.NUL`)
        /// opaque authentication response data generated by Authentication Method indicated by the plugin name field.
        var authResponse: ByteBuffer
        
        /// database (`string.NUL`)
        /// initial database for the connection -- this string should be interpreted using the character set indicated by character set field.
        var database: String
        
        /// auth plugin name (`string.NUL`)
        /// the Authentication Method used by the client to generate auth-response value in this packet. This is an UTF-8 string.
        var authPluginName: String
        
        /// connection attributes (pairs of `string.len_enc`)
        /// per-connection attributes sent by the client when `CLIENT_CONNECT_ATTRS` is available.
        ///
        /// - Note: Some attributes are set automatically by the default initializer when the capability flags indicate appropriate support. See
        ///   ``init(capabilities:maxPacketSize:characterSet:username:authResponse:database:authPluginName:connectionAttributes:)`` for more details.
        var connectionAttributes: [ConnectionAttributeName: String]
        
        /// Creates a new `MySQLHandshakeResponse41`
        ///
        /// - Note: The provided connection attributes are ignored if the capabilities flags do not specify `CLIENT_CONNECT_ATTRS`. Otherwise, the
        ///   provided attributes replace any attributes which would otherwise be added by default. Specifying `nil` (the default) results in sending
        ///   the default attribute set; specifying an empty dictionary results in sending no attributes whatsoever. To include some or all of the
        ///   default attributes alongside others, and/or with custom values,  use ``ConnectionAttributeName.defaultAttributeValues()`` to retrieve
        ///   the initial set of default values.
        init(
            capabilities: MySQLProtocol.CapabilityFlags,
            maxPacketSize: UInt32,
            characterSet: MySQLProtocol.CharacterSet,
            username: String,
            authResponse: ByteBuffer,
            database: String,
            authPluginName: String,
            connectionAttributes: [ConnectionAttributeName: String]? = nil
        ) {
            self.capabilities = capabilities
            self.maxPacketSize = maxPacketSize
            self.characterSet = characterSet
            self.username = username
            self.authResponse = authResponse
            self.database = database
            self.authPluginName = authPluginName
            self.connectionAttributes = connectionAttributes ?? ConnectionAttributeName.defaultAttributeValues()
        }
        
        /// `MySQLPacketEncodable` conformance.
        func encode(to packet: inout MySQLPacket, capabilities: MySQLProtocol.CapabilityFlags) throws {
            // Calculate the set of capability flags both reported by the server _and_ selected for this response.
            let sharedCapabilities = self.capabilities.intersection(capabilities)

            // Check auth response data isn't oversized, if needed. We don't support the case where `CLIENT_SECURE_CONNECTION`
            // isn't set, but that check is handled elsewhere so there's need to add additional logic for it here.
            guard sharedCapabilities.contains(.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) || self.authResponse.readableBytes <= UInt8.max else {
                throw Error.authResponseDataTooLong
            }
            guard sharedCapabilities.contains(.CLIENT_CONNECT_WITH_DB) || self.database.isEmpty else {
                throw Error.settingDatabaseEarlyUnsupported
            }
            guard sharedCapabilities.contains(.CLIENT_PLUGIN_AUTH) || self.authPluginName.isEmpty else {
                throw Error.authPluginsUnsupported
            }
            
            // N.B.: Send all specified capability flags; some are client-only and will be missing from the shared set.
            packet.payload.writeInteger(self.capabilities.general, endianness: .little)
            packet.payload.writeInteger(self.maxPacketSize, endianness: .little)
            packet.payload.writeInteger(self.characterSet.rawValue, endianness: .little)
            if !sharedCapabilities.contains(.CLIENT_LONG_PASSWORD) {
                packet.payload.writeBytes(repeatElement(UInt8.zero, count: 19))
                packet.payload.writeInteger(self.capabilities.mariaDBSpecific, endianness: .little, as: UInt32.self)
            } else {
                packet.payload.writeBytes(repeatElement(UInt8.zero, count: 23))
            }
            packet.payload.writeNullTerminatedString(self.username)
            if sharedCapabilities.contains(.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) {
                packet.payload.writeImmutableLengthEncodedSlice(self.authResponse)
            } else {
                assert(sharedCapabilities.contains(.CLIENT_SECURE_CONNECTION), "pre-4.1 auth not supported")
                packet.payload.writeInteger(UInt8(self.authResponse.readableBytes), endianness: .little)
                packet.payload.writeImmutableBuffer(self.authResponse)
            }
            if sharedCapabilities.contains(.CLIENT_CONNECT_WITH_DB) {
                packet.payload.writeNullTerminatedString(self.database)
            }
            if sharedCapabilities.contains(.CLIENT_PLUGIN_AUTH) {
                packet.payload.writeNullTerminatedString(self.authPluginName)
            }
            if sharedCapabilities.contains(.CLIENT_CONNECT_ATTRS) {
                var subdata = ByteBuffer()
                self.connectionAttributes.forEach {
                    subdata.writeLengthEncodedString($0.rawValue)
                    subdata.writeLengthEncodedString($1)
                }
                guard subdata.readableBytes < UInt16.max { throw Error.connectionAtrributesTooLarge }
                packet.payload.writeLengthEncodedSlice(&subdata)
            }
        }

        /// `MySQLPacketDecodable` conformance.
        static func decode(from packet: inout MySQLPacket, capabilities: MySQLProtocol.CapabilityFlags) throws -> HandshakeResponse41 {
            guard let rawClientCapabilities = packet.payload.readInteger(endianness: .little, as: UInt32.self) else { throw Error.missingCapabilities }
            guard let maxPacketSize = packet.payload.readInteger(endianness: .little, as: UInt32.self) else { throw Error.missingPacketSize }
            guard let rawCharacterSet = packet.payload.readInteger(endianness: .little, as: UInt8.self) else { throw Error.missingCharacterSet }
            
            var clientCapabilities = CapabilityFlags(rawValue: numericCast(rawClientCapabilities))
            if !CapabilityFlags(rawValue: numericCast(rawClientCapabilities)).union(capabilities).contains(.CLIENT_LONG_PASSWORD) {
                guard let reserved = packet.payload.readSlice(length: 19), reserved.readableBytesView.allSatisfy({ $0 == 0 }) else { throw Error.missingReservedData }
                guard let extraClientCapabilities = packet.payload.readInteger(endianness: .little, as: UInt32.self) else { throw Error.missingCapabilities }
                clientCapabilities.mariaDBSpecific = extraClientCapabilities
            } else {
                guard let reserved = packet.payload.readSlice(length: 23), reserved.readableBytesView.allSatisfy({ $0 == 0 }) else { throw Error.missingReservedData }
            }
            var sharedCapabilities = capabilities.intersection(clientCapabilities)
            
            let characterSet = MySQLProtocol.CharacterSet(rawValue: rawCharacterSet)
            
            guard let username = packet.payload.readNullTerminatedString() else { throw Error.missingUsername }
            
            let authResponse: ByteBuffer
            if sharedCapabilities.contains(.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) {
                guard let lenencAuthResponse = packet.payload.readLengthEncodedSlice() else { throw Error.missingAuthResponse }
                authResponse = lenencAuthResponse
            } else if sharedCapabilities.contains(.CLIENT_SECURE_CONNECTION) {
                guard let authResponseLength = packet.payload.readInteger(endianness: .little, as: UInt8.self) else { throw Error.missingAuthResponse }
                guard let secAuthResponse = packet.payload.readSlice(length: numericCast(authResponseLength)) else { throw Error.missingAuthResponse }
                authResponse = secAuthResponse
            } else {
                throw MySQLError.protocolError // pre-4.1 auth not supported
            }
            
            let database: String?
            if sharedCapabilities.contains(.CLIENT_CONNECT_WITH_DB) {
                guard let databaseName = packet.payload.readNullTerminatedString() else { throw Error.missingDatabaseName }
                database = databaseName
            } else {
                database = nil
            }
            
            let authPlugin: String?
            if sharedCapabilities.contains(.CLIENT_PLUGIN_AUTH) {
                guard let authPluginName = packet.payload.readNullTerminatedString() else { throw Error.missingAuthPluginName }
                authPlugin = authPluginName
            } else {
                authPlugin = nil
            }
            
            var connectionAttrs: [ConnectionAttributeName: String] = [:]
            if sharedCapabilities.contains(.CLIENT_CONNECT_ATTRS) {
                guard var attrData = packet.payload.readLengthEncodedSlice() else { throw Error.missingConnectionAttributes }
                while attrData.readableBytes > 0 {
                    guard let attrName = packet.payload.readLengthEncodedString() else { throw Error.missingConnectionAttributes }
                    guard let attrValue = packet.payload.readLengthEncodedString() else { throw Error.missingConnectionAttributes }
                    connectionAttrs[.init(name: attrName)] = attrValue
                }
            }
            
            return .init(
                capabilities: clientCapabilities,
                maxPacketSize: maxPacketSize,
                characterSet: characterSet,
                username: username,
                authResponse: authResponse,
                database: database ?? "",
                authPluginName: authPlugin ?? "",
                connectionAttributes: connectionAttrs
            )
        }

        enum Error: Swift.Error {
            case missingCapabilities
            case missingPacketSize
            case missingCharacterSet
            case missingReservedData
            case invalidReservedData([UInt8])
            case missingUsername
            case missingAuthResponse
            case missingDatabaseName
            case missingAuthPluginName
            case missingConnectionAttributes
            
            case authResponseDataTooLong // CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA not available and auth data longer than 255 bytes
            case settingDatabaseEarlyUnsupported // CLIENT_CONNECT_WITH_DB not available and a database name was specified for the connection
            case authPluginsUnsupported // CLIENT_PLUGIN_AUTH not available but an auth plugin was explicitly specified
            case connectionAtrributesTooLarge // CLIENT_CONNECT_ATTRS was specified and provided attributes exceed 64KiB of data
        }
    }
}

extension ByteBuffer {
    // Verbatim copy of `ByteBuffer.getNullTerminatedStringLength(at:)`.
    fileprivate func getNullTerminatedBytesLength(at index: Int) -> Int? {
        guard self.readerIndex <= index && index < self.writerIndex else {
            return nil
        }
        guard let endIndex = self.readableBytesView[index...].firstIndex(of: 0) else {
            return nil
        }
        return endIndex &- index
    }
}
