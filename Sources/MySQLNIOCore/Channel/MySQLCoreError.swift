/// The type for all errors generated by both sides of a MySQL connection
///
/// We wish to associate specific information with certain errors, which suggests an `enum` whose cases have
/// associated values. However, this causes compatibility problems if we need to add to the list of errors
/// at a later time, and the usual workaround of an `enum` hidden in a `struct` would not permit associating
/// values with only those kinds of errors to which those values are relevant.
///
/// The solution is to define each kind of error as its own single-case `enum`. The single case is always
/// named `error`, and has as its associated value(s) any data (if any) particular to that error type. All
/// such types also provide a `Context` which contains origin information for the error. This permits writing
/// code which catches errors in almost-natural fashion:
///
///     do {
///         try MySQLChannel.connect(...)
///     } catch MySQLCoreError.unknownAuthMethod.error(let method) {
///         // ...
///     }
///
/// > Note: It is clear that this approach involves violating the usual convention that type names start with
///   an uppercase letter, while properties and methods generally start with lowercase. This is a deliberate
///   choice made for this specific case to mimic, to the extent possible, the syntax one would use with a
///   non-frozen `enum`; it should absolutely not be considered normal.
///
/// > Tip: The initializers for the various error types are private. This is not an oversight; it is not
///   intended that creating errors of these 
public struct MySQLCoreError: Swift.Error, Sendable {
    /// Information common to all ``MySQLCoreError``s lives in an "error context".
    public struct Context: Sendable {
        /// A simple wrapper for a file name/line number pair
        public struct SourceLocation: Sendable, Hashable {
            public let file: String
            public let line: Int
            
            public static func here(file: String = #fileID, line: Int = #line) -> Self { self.init(file: file, line: line) }
            public init(file: String, line: Int) { (self.file, self.line) = (file, line) }
        }
        
        public let sourceLocation: SourceLocation?
        public let query: MySQLQuery?
        public let debugDescription: String?
        
        public init(sourceLocation: SourceLocation? = nil, query: MySQLQuery? = nil, debugDescription: String? = nil) {
            self.sourceLocation = sourceLocation
            self.query = query
            self.debugDescription = debugDescription
        }
    }
    
    /// An error occurred during packet decoding due to invalid data. Always causes immediate connection
    /// termination.
    public enum protocolViolation: _MySQLCoreError {
        case error(context: Context)
        
        public var context: Context { switch self { case .error(let context): return context } }
        
        init(context: Context) { self = .error(context: context) }
        init(query: MySQLQuery? = nil, debugDescription: String? = nil, file: String = #file, line: Int = #line) {
            self.init(context: .init(sourceLocation: .init(file: file, line: line), query: query, debugDescription: debugDescription))
        }
    }
    
    /// The server's protocol version is too old or too new, or the server doesn't support the minimum
    /// required capabilities. Always causes immediate connection termination.
    public enum incompatibleServer: _MySQLCoreError {
        case error(context: Context)
        
        public var context: Context { switch self { case .error(let context): return context } }
        
        init(context: Context) { self = .error(context: context) }
        init(query: MySQLQuery? = nil, debugDescription: String? = nil, file: String = #file, line: Int = #line) {
            self.init(context: .init(sourceLocation: .init(file: file, line: line), query: query, debugDescription: debugDescription))
        }
    }
    
    /// The server requested to authenticate using an unrecognized plugin. Always causes immediate
    /// connection termination.
    public enum unknownAuthMethod: _MySQLCoreError {
        case error(name: String, context: Context)

        public var context: Context { switch self { case .error(_, let context): return context } }
        
        init(name: String, context: Context) { self = .error(name: name, context: context) }
        init(name: String, query: MySQLQuery? = nil, debugDescription: String? = nil, file: String = #file, line: Int = #line) {
            self.init(name: name, context: .init(sourceLocation: .init(file: file, line: line), query: query, debugDescription: debugDescription))
        }
    }
    
    /// Authentication proceeded but did not succeed due to an error during the process (auth completed
    /// but access denied is reported as a server error). Always causes immediate connection termination.
    public enum authenticationFailure: _MySQLCoreError {
        case error(underlying: (any Swift.Error)?, context: Context)

        public var context: Context { switch self { case .error(_, let context): return context } }
        
        init(underlying: (any Swift.Error)? = nil, context: Context) { self = .error(underlying: underlying, context: context) }
        init(underlying: (any Swift.Error)? = nil, query: MySQLQuery? = nil, debugDescription: String? = nil, file: String = #file, line: Int = #line) {
            self.init(underlying: underlying, context: .init(sourceLocation: .init(file: file, line: line), query: query, debugDescription: debugDescription))
        }
    }
    
    /// Received an error packet from the server. The specific error determines whether or not the
    /// connection is terminated.
    public enum server: _MySQLCoreError {
        case error(code: UInt16, sqlState: String, message: String, context: Context)

        public var context: Context { switch self { case .error(_, _, _, let context): return context } }
        
        init(code: UInt16, sqlState: String, message: String, context: Context) {
            self = .error(code: code, sqlState: sqlState, message: message, context: context)
        }
        init(
            code: UInt16, sqlState: String, message: String,
            query: MySQLQuery? = nil, debugDescription: String? = nil, file: String = #file, line: Int = #line
        ) {
            self.init(
                code: code, sqlState: sqlState, message: message,
                context: .init(sourceLocation: .init(file: file, line: line), query: query, debugDescription: debugDescription)
            )
        }
    }
    
    /// A channel-level connection error occurred, such as an unexpected remote disconnect. The connection
    /// is already terminated.
    public enum connection: _MySQLCoreError {
        case error(underlying: (any Swift.Error)?, context: Context)

        public var context: Context { switch self { case .error(_, let context): return context } }
        
        init(underlying: (any Swift.Error)? = nil, context: Context) { self = .error(underlying: underlying, context: context) }
        init(underlying: (any Swift.Error)? = nil, query: MySQLQuery? = nil, debugDescription: String? = nil, file: String = #file, line: Int = #line) {
            self.init(underlying: underlying, context: .init(sourceLocation: .init(file: file, line: line), query: query, debugDescription: debugDescription))
        }
    }
    
    /// The connection has already been shut down or terminated; no further actions may be taken.
    public enum connectionInactive: _MySQLCoreError {
        case error(context: Context)

        public var context: Context { switch self { case .error(let context): return context } }
        
        init(context: Context) { self = .error(context: context) }
        init(query: MySQLQuery? = nil, debugDescription: String? = nil, file: String = #file, line: Int = #line) {
            self.init(context: .init(sourceLocation: .init(file: file, line: line), query: query, debugDescription: debugDescription))
        }
    }
}

public protocol _MySQLCoreError: Swift.Error, Sendable {
    var context: MySQLCoreError.Context { get }
}
